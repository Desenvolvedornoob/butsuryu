// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Definir valores fixos para as credenciais do Supabase
const SUPABASE_URL = 'https://xuywsfscrzypuppzaiks.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh1eXdzZnNjcnp5cHVwcHphaWtzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI4MjA3ODAsImV4cCI6MjA1ODM5Njc4MH0.eITrsXhXyTqSOmxHyiYu26FJODdYFbySUMdmWVIr0tE';
// NOTA: Esta chave precisa ser obtida do painel do Supabase -> Settings -> API -> service_role key
const SUPABASE_SERVICE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh1eXdzZnNjcnp5cHVwcHphaWtzIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc0MjgyMDc4MCwiZXhwIjoyMDU4Mzk2NzgwfQ.CMfKHfwTycizD7A2X_YcQrcqEWd9zPzttIbX2-XSCeQ';

// Cliente Supabase para usu√°rios normais (com autentica√ß√£o)
const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    persistSession: true,
    storageKey: 'supabase_auth_token',
    autoRefreshToken: true,
    detectSessionInUrl: true
  }
});

// Cliente Supabase para opera√ß√µes administrativas (sem autentica√ß√£o)
const supabaseAdmin = createClient<Database>(SUPABASE_URL, SUPABASE_SERVICE_KEY, {
  auth: {
    persistSession: false,
    autoRefreshToken: false,
    detectSessionInUrl: false
  }
});

// Cliente Supabase inicializado

// Verifica√ß√£o silenciosa da chave service_role
const testServiceKey = async () => {
  try {
    const { error } = await supabaseAdmin.auth.admin.listUsers();
    if (error) {
      console.warn('[Admin] Mudan√ßas de senha indispon√≠veis');
    }
  } catch (err: any) {
    // Falha silenciosa - fallback autom√°tico ativo
  }
};

setTimeout(testServiceKey, 2000);

// Log adicional para debug - movido para dentro de uma fun√ß√£o para evitar m√∫ltiplas inst√¢ncias
const setupAuthListener = () => {
  supabase.auth.onAuthStateChange((event, session) => {
    // Auth state change listener ativo
  });
};

// Configurar listener apenas uma vez
setupAuthListener();

// Fun√ß√µes para verifica√ß√£o de sess√£o
export const checkSessionAndRedirect = async () => {
  try {
    const { data } = await supabase.auth.getSession();
    if (data?.session) {
      console.log('[Supabase Client] Sess√£o ativa encontrada:', data.session.user.id);
      window.location.href = '/dashboard';
      return true;
    }
    console.log('[Supabase Client] Nenhuma sess√£o ativa encontrada');
    return false;
  } catch (error) {
    console.error('[Supabase Client] Erro ao verificar sess√£o:', error);
    return false;
  }
};

// Fun√ß√£o para for√ßar redirecionamento ao dashboard
export const forceDashboardNavigation = () => {
  console.log('[Supabase Client] For√ßando redirecionamento para dashboard');
  window.location.href = '/dashboard';
};

// Salvar token no localStorage
export const saveTokenToStorage = (token: string) => {
  try {
    localStorage.setItem('supabase_token', token);
    return true;
  } catch (error) {
    console.error('[Supabase Client] Erro ao salvar token:', error);
    return false;
  }
};

// Obter token do localStorage
export const getTokenFromStorage = () => {
  try {
    return localStorage.getItem('supabase_token');
  } catch (error) {
    console.error('[Supabase Client] Erro ao obter token:', error);
    return null;
  }
};

// Exportar cliente e fun√ß√µes
export { supabase };

// Fun√ß√£o para obter valores do localStorage
const getFromLocalStorage = (key: string): string | null => {
  try {
    return localStorage.getItem(key);
  } catch (error) {
    console.error(`[Supabase Client] Erro ao acessar localStorage para ${key}:`, error);
    return null;
  }
};

// Fun√ß√£o para salvar no localStorage
const saveToLocalStorage = (key: string, value: string): void => {
  try {
    localStorage.setItem(key, value);
  } catch (error) {
    console.error(`[Supabase Client] Erro ao salvar ${key} no localStorage:`, error);
  }
};

// Fun√ß√£o utilit√°ria para verificar se o cliente est√° usando valores de fallback
export const isUsingFallbackValues = () => {
  const defaultUrl = 'https://xuywsfscrzypuppzaiks.supabase.co';
  return SUPABASE_URL === defaultUrl;
};

const isSessionActive = async () => {
  const { data } = await supabase.auth.getSession();
  // Cliente inicializado e sess√£o verificada
  return !!data.session;
};
isSessionActive();

// Fun√ß√£o removida - j√° existe acima

// Exportar cliente admin para opera√ß√µes administrativas
export { supabaseAdmin };

export const createAdminUser = async (phone: string, password: string, userData: {
  first_name: string;
  department?: string;
  factory_id?: string;
}) => {
  try {
    // Primeiro, criar o usu√°rio no auth
    const { data: authData, error: authError } = await supabase.auth.signUp({
      phone,
      password,
      options: {
        data: {
          ...userData,
          role: 'admin'
        }
      }
    });

    if (authError) throw authError;

    // Depois, criar o perfil na tabela profiles
    const { error: profileError } = await supabase
      .from('profiles')
      .insert({
        id: authData.user?.id,
        phone,
        role: 'admin',
        ...userData,
        status: 'active'
      });

    if (profileError) throw profileError;

    return { success: true };
  } catch (error) {
    console.error('Error creating admin user:', error);
    return { success: false, error };
  }
};

// Fun√ß√£o para calcular o n√∫mero da semana (par ou √≠mpar)
const getCurrentWeekNumber = (date: Date) => {
  // Usar a semana ISO (segunda-feira como primeiro dia da semana)
  const year = date.getFullYear();
  const startOfYear = new Date(year, 0, 1);
  
  // Encontrar a primeira segunda-feira do ano
  const firstMonday = new Date(startOfYear);
  const dayOfWeek = startOfYear.getDay();
  const daysToAdd = dayOfWeek === 0 ? 1 : 8 - dayOfWeek; // Segunda-feira √© dia 1
  firstMonday.setDate(startOfYear.getDate() + daysToAdd);
  
  // Calcular semanas desde a primeira segunda-feira
  const timeDiff = date.getTime() - firstMonday.getTime();
  const daysSinceFirstMonday = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
  const weekNumber = Math.floor(daysSinceFirstMonday / 7) + 1;
  
  // Logs removidos para produ√ß√£o
  
  // Retornar 1 para √≠mpar, 2 para par
  return (weekNumber % 2) === 0 ? 2 : 1;
};

// Fun√ß√£o para verificar se um usu√°rio est√° no turno da manh√£ baseado na data espec√≠fica
export const isUserInMorningShift = async (userId: string, requestDate?: string): Promise<boolean> => {
  try {
    // Buscar o grupo e f√°brica do usu√°rio
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('group_name, factory_id')
      .eq('id', userId)
      .single();


    if (profileError || !profile?.group_name || !profile?.factory_id) {
      console.error('Erro ao buscar perfil do usu√°rio:', {
        profileError,
        group_name: profile?.group_name,
        factory_id: profile?.factory_id,
        userId
      });
      return false;
    }

    // Usar a data da solicita√ß√£o ou data atual
    const dateToCheck = requestDate ? new Date(requestDate) : new Date();

    // Calcular semana da data espec√≠fica (1 = √≠mpar, 2 = par)
    const weekNumber = getCurrentWeekNumber(dateToCheck);

    // Buscar configura√ß√£o de qual turno est√° de manh√£
    const { data: morningSetting, error: morningSettingError } = await supabase
      .from('morning_shift_setting')
      .select('morning_turno')
      .eq('id', 'current')
      .single();

    if (morningSettingError || !morningSetting?.morning_turno) {
      console.error('Erro ao buscar configura√ß√£o de turno da manh√£:', morningSettingError);
      return false;
    }

    const morningTurno = morningSetting.morning_turno;

    // Determinar qual turno est√° ativo de manh√£ nesta semana espec√≠fica
    const activeTurno = weekNumber === morningTurno ? morningTurno : (morningTurno === 1 ? 2 : 1);

    // Buscar configura√ß√£o de turnos da f√°brica para o turno ativo
    const { data: shiftConfig, error: shiftConfigError } = await supabase
      .from('factory_shift_config')
      .select('turno, groups')
      .eq('factory_id', profile.factory_id)
      .eq('turno', activeTurno);

    if (shiftConfigError || !shiftConfig || shiftConfig.length === 0) {
      console.error('Erro ao buscar configura√ß√£o de turnos:', shiftConfigError);
      return false;
    }

    // Verificar se o grupo do usu√°rio est√° no turno ativo desta data
    const activeGroups = shiftConfig[0].groups || [];
    const userInMorningShift = activeGroups.includes(profile.group_name);
    
    
    return userInMorningShift;
  } catch (error) {
    console.error('Erro ao verificar turno da manh√£:', error);
    return false;
  }
};

export const checkAndFixAdminProfile = async (userId: string) => {
  try {
    // Verificar o perfil atual
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();

    if (profileError) throw profileError;

    // Se o perfil n√£o for admin ou estiver inativo, corrigir
    if (profile.role !== 'admin' || profile.status !== 'active') {
      const { error: updateError } = await supabase
        .from('profiles')
        .update({
          role: 'admin',
          status: 'active'
        })
        .eq('id', userId);

      if (updateError) throw updateError;

      return { success: true, message: 'Perfil corrigido com sucesso' };
    }

    return { success: true, message: 'Perfil j√° est√° correto' };
  } catch (error) {
    console.error('Erro ao verificar/corrigir perfil:', error);
    return { success: false, error };
  }
};

export const saveRequest = async (requestData: {
  type: 'time-off' | 'early-departure' | 'lateness' | 'absence',
  user_id: string,
  reason: string,
  start_date: string,
  end_date?: string,
  time?: string,
  arrival_time?: string,
  substitute_id?: string,
  status?: 'pending' | 'approved' | 'rejected'
}) => {
  try {
    const { type, ...data } = requestData;
    
        // Verificar se √© uma solicita√ß√£o de folga (time-off) e aplicar limita√ß√µes apenas para n√£o-admins
        if (type === 'time-off') {
          try {
            // Verificar se o usu√°rio logado √© admin - admins n√£o t√™m limita√ß√µes
            const { data: { user } } = await supabase.auth.getUser();
            
            if (user) {
              const { data: userProfile } = await supabase
                .from('profiles')
                .select('role')
                .eq('id', user.id)
                .single();

              const isAdmin = userProfile?.role === 'admin' || userProfile?.role === 'superuser';

              if (!isAdmin) {
                // Apenas usu√°rios n√£o-admin t√™m limita√ß√µes
                
                // 1. Verificar anteced√™ncia m√≠nima de 2 dias
                const requestDate = new Date(data.start_date);
                const today = new Date();
                const timeDiff = requestDate.getTime() - today.getTime();
                const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));
                
                if (daysDiff < 2) {
                  return {
                    success: false,
                    error: 'Folgas devem ser solicitadas com pelo menos 2 dias de anteced√™ncia.',
                    code: 'INSUFFICIENT_ADVANCE_NOTICE'
                  };
                }

                // 2. Verificar turno da manh√£
                const userInMorningShift = await isUserInMorningShift(data.user_id, data.start_date);

                if (!userInMorningShift) {
                  return {
                    success: false,
                    error: 'Apenas funcion√°rios do turno da manh√£ podem solicitar folgas no momento.',
                    code: 'MORNING_SHIFT_REQUIRED'
                  };
                }

                // 3. Verificar limite global de folgas por dia
                const { checkDailyLeaveLimit } = await import('@/lib/leave-limit-utils');
                const limitCheck = await checkDailyLeaveLimit(data.start_date, data.user_id);

                if (!limitCheck.canRequest) {
                  return {
                    success: false,
                    error: limitCheck.message || 'Limite de folga atingido para esse dia. Qualquer d√∫vida fale com o respons√°vel.',
                    code: 'DAILY_LIMIT_EXCEEDED'
                  };
                }
              }
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è [saveRequest] Erro ao verificar permiss√µes, permitindo solicita√ß√£o:', error);
            // Se houver erro na verifica√ß√£o, permitir a solicita√ß√£o temporariamente
          }
        }
    
    // Definir status padr√£o como 'pending' se n√£o for especificado
    const status = data.status || (type === 'absence' ? 'approved' : 'pending');
    
    // Se for 'absence', tratamos de forma diferente porque n√£o existe no enum request_type
    if (type === 'absence') {
      // Criar um registro de falta como um time-off de um dia
      const absenceData: any = {
        user_id: data.user_id,
        start_date: data.start_date,
        end_date: data.start_date, // Mesmo dia
        reason: data.reason,
        status: 'approved' // Faltas s√£o sempre aprovadas
      };
      
      // Adicionar substituto se fornecido
      if (data.substitute_id && data.substitute_id !== 'none') {
        absenceData.substitute_id = data.substitute_id;
      }
      
      const { data: insertedData, error } = await supabase
        .from('time_off')
        .insert(absenceData)
        .select();
      
      if (error) throw error;
      
      return { 
        success: true, 
        data: insertedData[0],
        message: 'Falta registrada com sucesso'
      };
    }
    
    // Para os outros tipos, usar a tabela requests
    const { data: insertedData, error } = await supabase
      .from('requests')
      .insert({
        ...data,
        type, // Agora type s√≥ pode ser 'time-off', 'early-departure' ou 'lateness'
        status,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select();
    
    if (error) throw error;

    // Inserir tabela espec√≠fica dependendo do tipo
    let specificError = null;
    
    if (type === 'time-off') {
      
      const timeOffData: any = {
        id: insertedData[0].id,
        user_id: data.user_id,
        start_date: data.start_date,
        end_date: data.end_date || data.start_date,
        reason: data.reason,
        status: status
      };
      
      // Adicionar substituto se fornecido
      if (data.substitute_id && data.substitute_id !== 'none') {
        timeOffData.substitute_id = data.substitute_id;
      }
      
      const { error: timeOffError } = await supabase
        .from('time_off')
        .insert(timeOffData);
        
      specificError = timeOffError;
    } 
    else if (type === 'early-departure') {
      const earlyDepartureData: any = {
        id: insertedData[0].id,
        user_id: data.user_id,
        date: data.start_date,
        time: data.time || '00:00',
        reason: data.reason,
        status: status
      };
      
      // Adicionar substitute_id se fornecido
      if (data.substitute_id && data.substitute_id !== 'none') {
        earlyDepartureData.substitute_id = data.substitute_id;
      }
      
      const { error: earlyDepartureError } = await supabase
        .from('early_departures')
        .insert(earlyDepartureData);
        
      specificError = earlyDepartureError;
    }
    else if (type === 'lateness') {
      const latenessData: any = {
        id: insertedData[0].id,
        user_id: data.user_id,
        date: data.start_date,
        arrival_time: data.arrival_time || '00:00',
        reason: data.reason,
        status: status
      };
      
      // Adicionar substitute_id se fornecido
      if (data.substitute_id && data.substitute_id !== 'none') {
        latenessData.substitute_id = data.substitute_id;
      }
      
      const { error: latenessError } = await supabase
        .from('lateness')
        .insert(latenessData);
        
      specificError = latenessError;
    }
    
    if (specificError) {
      console.warn('Erro ao inserir na tabela espec√≠fica:', specificError);
      // N√£o interromper a opera√ß√£o se falhar na tabela espec√≠fica
    }

    return { 
      success: true, 
      data: insertedData[0],
      message: 'Solicita√ß√£o salva com sucesso'
    };
  } catch (error) {
    console.error('Erro ao salvar solicita√ß√£o:', error);
    return { success: false, error };
  }
};

export const deleteAllUsers = async () => {
  try {
    // Primeiro deleta todos os perfis
    const { error: profilesError } = await supabase
      .from('profiles')
      .delete()
      .neq('id', ''); // deleta todos os registros

    if (profilesError) {
      console.error('Erro ao deletar perfis:', profilesError);
      throw profilesError;
    }

    // Depois deleta todos os usu√°rios do sistema de autentica√ß√£o
    const { data: { users }, error: usersError } = await supabase.auth.admin.listUsers();
    
    if (usersError) {
      console.error('Erro ao listar usu√°rios:', usersError);
      throw usersError;
    }

    // Deleta cada usu√°rio individualmente
    for (const user of users) {
      const { error: deleteError } = await supabase.auth.admin.deleteUser(user.id);
      if (deleteError) {
        console.error(`Erro ao deletar usu√°rio ${user.id}:`, deleteError);
        throw deleteError;
      }
    }

    console.log('Todos os usu√°rios e perfis foram deletados com sucesso');
    return { success: true };

  } catch (error) {
    console.error('Erro ao deletar usu√°rios:', error);
    return { success: false, error };
  }
};

export const loadRequests = async (userId: string) => {
  try {
    // Validar se o userId √© v√°lido
    if (!userId || userId.trim() === '') {
      console.error('UserId inv√°lido ou vazio:', userId);
      return { success: false, error: 'UserId inv√°lido' };
    }

    console.log('Carregando requests para userId:', userId);

    // Buscar todas as requisi√ß√µes do usu√°rio da tabela requests
    const { data: requests, error: requestsError } = await supabase
      .from('requests')
      .select('*')
      .eq('user_id', userId);

    if (requestsError) {
      console.error('Erro ao buscar requests:', requestsError);
      throw requestsError;
    }

    // Buscar solicita√ß√µes de time_off do usu√°rio
    const { data: timeOffRequests, error: timeOffError } = await supabase
      .from('time_off')
      .select('*')
      .eq('user_id', userId);

    if (timeOffError) {
      console.error('Erro ao buscar time_off:', timeOffError);
      throw timeOffError;
    }

    // Buscar solicita√ß√µes de early_departures do usu√°rio
    const { data: earlyDeparturesRequests, error: earlyDeparturesError } = await supabase
      .from('early_departures')
      .select('*')
      .eq('user_id', userId);

    if (earlyDeparturesError) {
      console.error('Erro ao buscar early_departures:', earlyDeparturesError);
      throw earlyDeparturesError;
    }

    // Buscar solicita√ß√µes de lateness do usu√°rio
    const { data: latenessRequests, error: latenessError } = await supabase
      .from('lateness')
      .select('*')
      .eq('user_id', userId);

    if (latenessError) {
      console.error('Erro ao buscar lateness:', latenessError);
      throw latenessError;
    }

    // Buscar perfil do usu√°rio para obter o nome
    const { data: userProfile, error: profileError } = await supabase
      .from('profiles')
      .select('first_name')
      .eq('id', userId)
      .single();

    if (profileError) {
      console.error('Erro ao buscar perfil do usu√°rio:', profileError);
    }

    const allRequests: any[] = [];

    // Processar requests da tabela requests
    (requests || []).forEach(req => {
      allRequests.push({
        id: req.id,
        type: req.type,
        status: req.status,
        date: req.start_date,
        endDate: req.end_date,
        time: req.time,
        arrivalTime: req.arrival_time,
        reason: req.reason,
        created_at: req.created_at,
        user_id: req.user_id,
        userName: userProfile?.first_name || 'Usu√°rio n√£o encontrado'
      });
    });

    // Processar time_off que n√£o est√£o na tabela requests
    (timeOffRequests || []).forEach(req => {
      // Verificar se j√° existe na tabela requests
      const existsInRequests = requests?.some(r => r.id === req.id);
      if (!existsInRequests) {
        allRequests.push({
          id: req.id,
          type: 'time-off',
          status: req.status,
          date: req.start_date,
          endDate: req.end_date,
          reason: req.reason,
          created_at: req.created_at,
          user_id: req.user_id,
          userName: userProfile?.first_name || 'Usu√°rio n√£o encontrado'
        });
      }
    });

    // Processar early_departures que n√£o est√£o na tabela requests
    (earlyDeparturesRequests || []).forEach(req => {
      const existsInRequests = requests?.some(r => r.id === req.id);
      if (!existsInRequests) {
        allRequests.push({
          id: req.id,
          type: 'early-departure',
          status: req.status,
          date: req.date, // Corrigido: early_departures usa 'date', n√£o 'start_date'
          endDate: req.date, // early_departures n√£o tem end_date, usar date
          time: req.time,
          reason: req.reason,
          created_at: req.created_at,
          user_id: req.user_id,
          userName: userProfile?.first_name || 'Usu√°rio n√£o encontrado'
        });
      }
    });

    // Processar lateness que n√£o est√£o na tabela requests
    (latenessRequests || []).forEach(req => {
      const existsInRequests = requests?.some(r => r.id === req.id);
      if (!existsInRequests) {
        allRequests.push({
          id: req.id,
          type: 'lateness',
          status: req.status,
          date: req.date, // Corrigido: lateness usa 'date', n√£o 'start_date'
          endDate: req.date, // lateness n√£o tem end_date, usar date
          arrivalTime: req.arrival_time,
          reason: req.reason,
          created_at: req.created_at,
          user_id: req.user_id,
          userName: userProfile?.first_name || 'Usu√°rio n√£o encontrado'
        });
      }
    });

    // Ordenar por data de cria√ß√£o (mais recente primeiro)
    const formattedRequests = allRequests.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());

    console.log('Requests carregados com sucesso:', formattedRequests.length);
    return { success: true, data: formattedRequests };
  } catch (error) {
    console.error('Erro ao carregar requisi√ß√µes:', error);
    return { success: false, error };
  }
};

export const loadAllRequests = async () => {
  try {

    // Buscar todas as requisi√ß√µes (sem JOIN por enquanto)
    const { data: requests, error: requestsError } = await supabase
      .from('requests')
      .select('*');

    if (requestsError) {
      console.error('Erro ao buscar requests:', requestsError);
      throw requestsError;
    }
    

    // Buscar todos os time_off aprovados (sem JOIN)
    const { data: allTimeOff, error: timeOffError } = await supabase
      .from('time_off')
      .select('*')
      .eq('status', 'approved');

    if (timeOffError) {
      console.error('Erro ao buscar time_off:', timeOffError);
      throw timeOffError;
    }

    // Filtrar no JavaScript para encontrar faltas (mesmo dia)
    const filteredAbsences = allTimeOff?.filter(timeOff => 
      timeOff.start_date === timeOff.end_date
    ) || [];

    // Buscar todos os profiles de uma vez (incluindo substitutos)
    const allUserIds = [
      ...(requests || []).map(req => req.user_id),
      ...filteredAbsences.map(abs => abs.user_id),
      ...(requests || []).map(req => req.substitute_id).filter(Boolean),
      ...filteredAbsences.map(abs => abs.substitute_id).filter(Boolean)
    ];
    const uniqueUserIds = [...new Set(allUserIds)];
    
    let profilesMap = new Map();
    if (uniqueUserIds.length > 0) {
      const { data: profiles } = await supabase
        .from('profiles')
        .select('id, first_name')
        .in('id', uniqueUserIds);
      
      
      profiles?.forEach(profile => {
        profilesMap.set(profile.id, profile);
      });
    }

    // Formatar todas as requisi√ß√µes no mesmo formato
    const formattedRequests = [
      ...(requests || []).map(req => {
        const profile = profilesMap.get(req.user_id);
        const substituteProfile = req.substitute_id ? profilesMap.get(req.substitute_id) : null;
        
        
        return {
          id: req.id,
          type: req.type,
          status: req.status,
          date: req.start_date,
          endDate: req.end_date,
          time: req.time,
          arrivalTime: req.arrival_time,
          reason: req.reason,
          created_at: req.created_at,
          user_id: req.user_id,
          userName: profile ? profile.first_name : 'N/A',
          substitute_id: req.substitute_id,
          substituteName: substituteProfile ? substituteProfile.first_name : null
        };
      }),
      ...filteredAbsences.map(abs => {
        const profile = profilesMap.get(abs.user_id);
        const substituteProfile = abs.substitute_id ? profilesMap.get(abs.substitute_id) : null;
        return {
          id: `absence-${abs.id}`, // Garantir ID √∫nico para aus√™ncias
          type: 'absence',
          status: abs.status,
          date: abs.start_date,
          endDate: abs.end_date,
          reason: abs.reason,
          created_at: abs.created_at,
          user_id: abs.user_id,
          userName: profile ? profile.first_name : 'N/A',
          substitute_id: abs.substitute_id,
          substituteName: substituteProfile ? substituteProfile.first_name : null
        };
      })
    ].sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime());

    return { success: true, data: formattedRequests };
  } catch (error) {
    console.error('Erro ao carregar requisi√ß√µes:', error);
    return { success: false, error };
  }
};

export const updateRequestStatus = async (requestId: string, status: 'approved' | 'rejected', rejectReason?: string) => {
  try {
    // Verificar RLS primeiro
    await checkAndFixRLS();
    
    // Obter o usu√°rio atual que est√° fazendo a a√ß√£o
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      throw new Error('Usu√°rio n√£o autenticado');
    }
    
    const reviewedAt = new Date().toISOString();
    const updateData = {
      status,
      updated_at: reviewedAt,
      reviewed_at: reviewedAt,
      reject_reason: rejectReason,
      approved_by: status === 'approved' ? user.id : null,
      rejected_by: status === 'rejected' ? user.id : null
    };
    
    // Primeiro tentar atualizar na tabela requests
    const { data: request, error: requestError } = await supabase
      .from('requests')
      .update(updateData)
      .eq('id', requestId)
      .select()
      .maybeSingle();

    // Se n√£o encontrou na tabela requests, pode ser uma solicita√ß√£o apenas em time_off
    if (!request && !requestError) {
      // Tentar atualizar diretamente na tabela time_off
      const { data: timeOffData, error: timeOffError } = await supabase
        .from('time_off')
        .update(updateData)
        .eq('id', requestId)
        .select()
        .single();
      
      if (timeOffError) {
        throw timeOffError;
      }
      
      return { success: true, data: timeOffData };
    }

    if (requestError) {
      throw requestError;
    }

    // Se encontrou na tabela requests, atualizar tamb√©m na tabela espec√≠fica
    if (request && request.type === 'time-off') {
      const { error } = await supabase
        .from('time_off')
        .update(updateData)
        .eq('id', requestId);
      if (error) console.warn('Erro ao atualizar time_off:', error);
    } 
    else if (request && request.type === 'early-departure') {
      const { error } = await supabase
        .from('early_departures')
        .update(updateData)
        .eq('id', requestId);
      if (error) console.warn('Erro ao atualizar early_departures:', error);
    }
    else if (request && request.type === 'lateness') {
      const { error } = await supabase
        .from('lateness')
        .update(updateData)
        .eq('id', requestId);
      if (error) console.warn('Erro ao atualizar lateness:', error);
    }

    return { success: true, data: request };
  } catch (error) {
    console.error('Erro ao atualizar status da requisi√ß√£o:', error);
    return { success: false, error };
  }
};

export const updateRequest = async (
  requestId: string, 
  updateData: {
    type: 'time-off' | 'early-departure' | 'lateness' | 'absence',
    user_id?: string,
    reason?: string,
    start_date?: string,
    end_date?: string,
    time?: string,
    arrival_time?: string,
    status?: 'pending' | 'approved' | 'rejected',
    substitute_id?: string
  }
) => {
  try {
    
    // Verificar RLS e criar perfil admin se necess√°rio
    await checkAndFixRLS();
    
    const { type, ...data } = updateData;
    const currentTime = new Date().toISOString();
    
    // Converter 'absence' para 'time-off' para o banco de dados
    // O tipo 'absence' √© detectado pela l√≥gica de start_date === end_date
    const dbType = type === 'absence' ? 'time-off' : type;
    
    // Verificar se o usu√°rio √© admin para ter permiss√µes de edi√ß√£o
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      throw new Error('Usu√°rio n√£o autenticado');
    }
    
    // Verificar perfil do usu√°rio
    const { data: userProfile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single();
    
    if (!userProfile || (userProfile.role !== 'admin' && userProfile.role !== 'superuser')) {
      throw new Error('Usu√°rio n√£o tem permiss√£o para editar solicita√ß√µes');
    }
    
    // Buscar a solicita√ß√£o em todas as tabelas poss√≠veis
    let existingRequest = null;
    let existingTimeOff = null;
    let existingEarlyDeparture = null;
    let existingLateness = null;
    let currentTable = null;
    
    // Buscar na tabela requests
    const { data: requestData, error: requestError } = await supabase
      .from('requests')
      .select('*')
      .eq('id', requestId)
      .maybeSingle();
    
    if (requestData) {
      existingRequest = requestData;
      currentTable = 'requests';
    }
    
    // Buscar na tabela time_off
    const { data: timeOffData, error: timeOffError } = await supabase
      .from('time_off')
      .select('*')
      .eq('id', requestId)
      .maybeSingle();
    
    if (timeOffData) {
      existingTimeOff = timeOffData;
      currentTable = 'time_off';
    }
    
    // Buscar na tabela early_departures
    const { data: earlyData, error: earlyError } = await supabase
      .from('early_departures')
      .select('*')
      .eq('id', requestId)
      .maybeSingle();
    
    if (earlyData) {
      existingEarlyDeparture = earlyData;
      currentTable = 'early_departures';
    }
    
    // Buscar na tabela lateness
    const { data: latenessData, error: latenessError } = await supabase
      .from('lateness')
      .select('*')
      .eq('id', requestId)
      .maybeSingle();
    
    if (latenessData) {
      existingLateness = latenessData;
      currentTable = 'lateness';
    }
    
    // Se n√£o encontrou em nenhuma tabela
    if (!existingRequest && !existingTimeOff && !existingEarlyDeparture && !existingLateness) {
      throw new Error(`Solicita√ß√£o com ID ${requestId} n√£o encontrada em nenhuma tabela`);
    }
    
    
    // Se encontrou na tabela time_off (pode ser absence)
    if (existingTimeOff) {
      
      // Se for absence (est√° apenas em time_off com start_date = end_date) OU se o usu√°rio quer mudar para absence
      if (existingTimeOff && (existingTimeOff.start_date === existingTimeOff.end_date || type === 'absence')) {
        
        // Verificar se h√° inconsist√™ncia entre requests e time_off
        if (existingRequest && existingRequest.type !== 'time-off') {
          
          // Corrigir a inconsist√™ncia atualizando o tipo na tabela requests
          // 'absence' √© representado como 'time-off' na tabela requests
          const { error: fixError } = await supabase
            .from('requests')
            .update({ type: 'time-off' })
            .eq('id', requestId);
          
          if (fixError) {
            console.error('‚ùå Erro ao corrigir inconsist√™ncia:', fixError);
          } else {
          }
        }
        
        // Verificar se h√° mudan√ßa de tipo baseada na tabela requests
        const currentRequestType = existingRequest?.type;
        
        // DETECTAR MUDAN√áA REAL: Se o usu√°rio quer mudar de "folga" para "falta"
        // currentRequestType = 'time-off' (folga) + type = 'absence' (falta) = MUDAN√áA REAL
        const isChangingFromTimeOffToAbsence = currentRequestType === 'time-off' && type === 'absence';
        
        // DETECTAR MUDAN√áA REAL: Se o usu√°rio quer mudar de "falta" para "folga"
        // Neste caso, a solicita√ß√£o atual √© absence (start_date === end_date) mas o usu√°rio quer time-off
        const isChangingFromAbsenceToTimeOff = (existingTimeOff.start_date === existingTimeOff.end_date) && type === 'time-off';
        
        // Para absence, comparar com 'time-off' (que √© como absence √© representado na tabela requests)
        const expectedRequestType = type === 'absence' ? 'time-off' : type;
        const needsTypeChange = currentRequestType !== expectedRequestType || isChangingFromTimeOffToAbsence || isChangingFromAbsenceToTimeOff;
        
        
        // Se o tipo foi alterado de 'absence' para outro tipo
        if (type !== 'absence') {
          
          // Verificar se j√° existe na tabela requests
          const { data: existingRequestCheck } = await supabase
            .from('requests')
            .select('id')
            .eq('id', requestId)
            .maybeSingle();
          
          const requestsData: any = {
            id: requestId,
            type: dbType as 'time-off' | 'early-departure' | 'lateness',
            user_id: data.user_id || existingTimeOff.user_id,
            start_date: data.start_date || existingTimeOff.start_date,
            end_date: dbType === 'time-off' ? (data.end_date || (existingTimeOff.start_date === existingTimeOff.end_date ? new Date(new Date(existingTimeOff.start_date).getTime() + 24 * 60 * 60 * 1000).toISOString() : existingTimeOff.end_date)) : null,
            reason: data.reason || existingTimeOff.reason,
            status: data.status || existingTimeOff.status,
            time: dbType === 'early-departure' ? (data.time || '00:00') : null,
            arrival_time: dbType === 'lateness' ? (data.arrival_time || '00:00') : null,
            created_at: existingTimeOff.created_at,
            updated_at: currentTime
          };
          
          // Adicionar substitute_id se fornecido
          if (data.substitute_id !== undefined) {
            requestsData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (existingTimeOff.substitute_id) {
            requestsData.substitute_id = existingTimeOff.substitute_id;
          }
          
          if (existingRequestCheck) {
            // Atualizar se j√° existe
            const { error: updateError } = await supabase
              .from('requests')
              .update(requestsData)
              .eq('id', requestId);
            
            if (updateError) throw updateError;
            
            // Atualizar tamb√©m a tabela time_off se mudou de absence para time-off
            if (dbType === 'time-off') {
              const timeOffUpdateData: any = {
                start_date: data.start_date || existingTimeOff.start_date,
                end_date: data.end_date || existingTimeOff.end_date,
                reason: data.reason || existingTimeOff.reason,
                status: data.status || existingTimeOff.status,
                updated_at: currentTime
              };
              
              // Adicionar substitute_id se fornecido
              if (data.substitute_id !== undefined) {
                timeOffUpdateData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
              } else if (existingTimeOff.substitute_id) {
                timeOffUpdateData.substitute_id = existingTimeOff.substitute_id;
              }
              
              const { error: timeOffUpdateError } = await supabase
                .from('time_off')
                .update(timeOffUpdateData)
                .eq('id', requestId);
              
              if (timeOffUpdateError) throw timeOffUpdateError;
            }
          } else {
            // Inserir se n√£o existe
            console.log('‚ûï Inserindo novo registro na tabela requests...');
            const { error: insertError } = await supabase
              .from('requests')
              .insert(requestsData);
            
            if (insertError) throw insertError;
          }
          
          // Atualizar ou remover da tabela time_off
          if (dbType === 'time-off') {
            // Atualizar time_off
            const { error } = await supabase
              .from('time_off')
              .update({
                start_date: data.start_date || existingTimeOff.start_date,
                end_date: data.end_date || existingTimeOff.end_date,
                reason: data.reason || existingTimeOff.reason,
                status: data.status || existingTimeOff.status,
                updated_at: currentTime
              })
              .eq('id', requestId);
            
            if (error) throw error;
          } else {
            // Remover da tabela time_off se o novo tipo n√£o for 'time-off'
            if (dbType === 'early-departure' || dbType === 'lateness') {
                const { error } = await supabase
                .from('time_off')
                .delete()
                .eq('id', requestId);
                if (error) throw error;
            }
          }
          
          // Inserir na tabela espec√≠fica do novo tipo
          if (dbType === 'early-departure') {
            const { error } = await supabase
              .from('early_departures')
              .insert({
                id: requestId,
                user_id: data.user_id || existingTimeOff.user_id,
                date: data.start_date || existingTimeOff.start_date,
                time: data.time || '00:00',
                reason: data.reason || existingTimeOff.reason,
                status: data.status || existingTimeOff.status
              });
            
            if (error) throw error;
          }
          else if (dbType === 'lateness') {
            const { error } = await supabase
              .from('lateness')
              .insert({
                id: requestId,
                user_id: data.user_id || existingTimeOff.user_id,
                date: data.start_date || existingTimeOff.start_date,
                arrival_time: data.arrival_time || '00:00',
                reason: data.reason || existingTimeOff.reason,
                status: data.status || existingTimeOff.status
              });
            
            if (error) throw error;
          }
        } else {
          // Se continua como 'absence', verificar se precisa mudar o tipo na tabela requests
          
          // Se o tipo na tabela requests √© diferente do esperado, precisa atualizar
          if (needsTypeChange) {
            if (isChangingFromTimeOffToAbsence) {
              console.log('üîß MUDAN√áA ESPECIAL: De folga para falta - mantendo time-off na tabela requests');
              console.log('üîß MAS alterando dados na tabela time_off para representar falta');
            } else {
              console.log('üîß Atualizando tipo na tabela requests de', currentRequestType, 'para', expectedRequestType);
              
              const { error: updateTypeError } = await supabase
                .from('requests')
                .update({ type: expectedRequestType })
                .eq('id', requestId);
              
              if (updateTypeError) {
                console.error('‚ùå Erro ao atualizar tipo na tabela requests:', updateTypeError);
              } else {
                console.log('‚úÖ Tipo atualizado na tabela requests:', expectedRequestType);
              }
            }
          } else {
          }
          // Para absence, garantir que end_date = start_date
          const startDate = data.start_date || existingTimeOff.start_date;
          const endDate = type === 'absence' ? startDate : (data.end_date || existingTimeOff.end_date);
          
          const updateData: any = {
            user_id: data.user_id || existingTimeOff.user_id,
            start_date: startDate,
            end_date: endDate,
            reason: data.reason || existingTimeOff.reason,
            status: data.status || existingTimeOff.status,
            updated_at: currentTime
          };
          
          // Adicionar substitute_id se fornecido
          if (data.substitute_id !== undefined) {
            updateData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (existingTimeOff.substitute_id) {
            updateData.substitute_id = existingTimeOff.substitute_id;
          }
          
          
          const { error } = await supabase
            .from('time_off')
            .update(updateData)
            .eq('id', requestId);
          
          if (error) throw error;
        }
        
        return { success: true, data: { id: requestId, ...updateData } };
      } else {
        
        // Se existingTimeOff existe mas n√£o √© absence (time-off normal)
        
        // Atualizar dados na tabela time_off
        const updateData: any = {
          user_id: data.user_id || existingTimeOff.user_id,
          start_date: data.start_date || existingTimeOff.start_date,
          end_date: data.end_date || existingTimeOff.end_date,
          reason: data.reason || existingTimeOff.reason,
          status: data.status || existingTimeOff.status,
          updated_at: currentTime
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          updateData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
        } else if (existingTimeOff.substitute_id) {
          updateData.substitute_id = existingTimeOff.substitute_id;
        }
        
        
        const { data: timeOffResult, error } = await supabase
          .from('time_off')
          .update(updateData)
          .eq('id', requestId)
          .select();
        
        if (error) {
          throw error;
        }
        
        
        // Atualizar tamb√©m na tabela requests se existir
        if (existingRequest) {
          const requestsUpdateData: any = {
            user_id: data.user_id || existingRequest.user_id,
            start_date: data.start_date || existingRequest.start_date,
            end_date: data.end_date || existingRequest.end_date,
            reason: data.reason || existingRequest.reason,
            status: data.status || existingRequest.status,
            updated_at: currentTime
          };
          
          // Adicionar substitute_id se fornecido
          if (data.substitute_id !== undefined) {
            requestsUpdateData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (existingRequest.substitute_id) {
            requestsUpdateData.substitute_id = existingRequest.substitute_id;
          }
          
          const { data: requestsResult, error: requestError } = await supabase
            .from('requests')
            .update(requestsUpdateData)
            .eq('id', requestId)
            .select();
          
          if (requestError) {
            throw requestError;
          }
        }
        
        return { success: true, data: { id: requestId, ...updateData } };
      }
    }
    
    // Se encontrou em tabelas espec√≠ficas (lateness, early_departures) mas n√£o em requests
    if (existingLateness || existingEarlyDeparture) {
      console.log('üîÑ Processando solicita√ß√£o de tabela espec√≠fica...');
      
      // Determinar o tipo atual baseado na tabela encontrada
      const currentType = existingLateness ? 'lateness' : 'early-departure';
      const currentData = existingLateness || existingEarlyDeparture;
      
      
      // Se o tipo mudou
      if (type !== currentType) {
        
        // Caso especial: mudan√ßa para 'absence'
        if (type === 'absence') {
          console.log('‚úÖ Mudando para absence - removendo da tabela espec√≠fica...');
          
          // Remover da tabela espec√≠fica
          if (existingLateness) {
            await supabase.from('lateness').delete().eq('id', requestId);
          } else if (existingEarlyDeparture) {
            await supabase.from('early_departures').delete().eq('id', requestId);
          }
          
          // Inserir em time_off como absence
          const absenceData: any = {
            id: requestId,
            user_id: data.user_id || currentData.user_id,
            start_date: data.start_date || currentData.date,
            end_date: data.start_date || currentData.date, // Para absence, start_date = end_date
            reason: data.reason || currentData.reason,
            status: data.status || currentData.status
          };
          
          // Adicionar substitute_id se fornecido
          if (data.substitute_id !== undefined) {
            absenceData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (currentData.substitute_id) {
            absenceData.substitute_id = currentData.substitute_id;
          }
          
          const { error: insertError } = await supabase
            .from('time_off')
            .insert(absenceData);
          
          if (insertError) throw insertError;
          
          return { success: true, data: { id: requestId, ...updateData } };
        }
        
        // Outras mudan√ßas de tipo (n√£o para absence)
        // Remover da tabela espec√≠fica atual
        if (existingLateness) {
          await supabase.from('lateness').delete().eq('id', requestId);
        } else if (existingEarlyDeparture) {
          await supabase.from('early_departures').delete().eq('id', requestId);
        }
        
        // Inserir na tabela requests
        const requestsData: any = {
          id: requestId,
          type: dbType as 'time-off' | 'early-departure' | 'lateness',
          user_id: data.user_id || currentData.user_id,
          start_date: data.start_date || currentData.date,
          end_date: dbType === 'time-off' ? (data.end_date || currentData.date) : null,
          time: dbType === 'early-departure' ? (data.time || currentData.time) : null,
          arrival_time: dbType === 'lateness' ? (data.arrival_time || currentData.arrival_time) : null,
          reason: data.reason || currentData.reason,
          status: data.status || currentData.status,
          created_at: currentTime,
          updated_at: currentTime
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          requestsData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
        } else if (currentData.substitute_id) {
          requestsData.substitute_id = currentData.substitute_id;
        }
        
        const { error: insertError } = await supabase
          .from('requests')
          .insert(requestsData);
        
        if (insertError) throw insertError;
        
        // Inserir na nova tabela espec√≠fica
        if (dbType === 'time-off') {
          const timeOffData: any = {
            id: requestId,
            user_id: data.user_id || currentData.user_id,
            start_date: data.start_date || currentData.date,
            end_date: data.end_date || currentData.date,
            reason: data.reason || currentData.reason,
            status: data.status || currentData.status
          };
          
          if (data.substitute_id !== undefined) {
            timeOffData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (currentData.substitute_id) {
            timeOffData.substitute_id = currentData.substitute_id;
          }
          
          const { error } = await supabase
            .from('time_off')
            .insert(timeOffData);
          
          if (error) throw error;
        } else if (dbType === 'early-departure') {
          const earlyData: any = {
            id: requestId,
            user_id: data.user_id || currentData.user_id,
            date: data.start_date || currentData.date,
            time: data.time || '00:00',
            reason: data.reason || currentData.reason,
            status: data.status || currentData.status
          };
          
          if (data.substitute_id !== undefined) {
            earlyData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (currentData.substitute_id) {
            earlyData.substitute_id = currentData.substitute_id;
          }
          
          const { error } = await supabase
            .from('early_departures')
            .insert(earlyData);
          
          if (error) throw error;
        } else if (dbType === 'lateness') {
          const latenessData: any = {
            id: requestId,
            user_id: data.user_id || currentData.user_id,
            date: data.start_date || currentData.date,
            arrival_time: data.arrival_time || '00:00',
            reason: data.reason || currentData.reason,
            status: data.status || currentData.status
          };
          
          if (data.substitute_id !== undefined) {
            latenessData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (currentData.substitute_id) {
            latenessData.substitute_id = currentData.substitute_id;
          }
          
          const { error } = await supabase
            .from('lateness')
            .insert(latenessData);
          
          if (error) throw error;
        }
        
        return { success: true, data: { id: requestId, ...updateData } };
      } else {
        // Tipo n√£o mudou, apenas atualizar a tabela espec√≠fica
        console.log('üìù Tipo n√£o mudou, apenas atualizando dados na tabela espec√≠fica...');
        
        if (existingLateness) {
          const latenessUpdateData: any = {
            user_id: data.user_id || currentData.user_id,
            date: data.start_date || currentData.date,
            arrival_time: data.arrival_time || currentData.arrival_time,
            reason: data.reason || currentData.reason,
            status: data.status || currentData.status
          };
          
          if (data.substitute_id !== undefined) {
            latenessUpdateData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (currentData.substitute_id) {
            latenessUpdateData.substitute_id = currentData.substitute_id;
          }
          
          const { error } = await supabase
            .from('lateness')
            .update(latenessUpdateData)
            .eq('id', requestId);
          
          if (error) throw error;
        } else if (existingEarlyDeparture) {
          const earlyUpdateData: any = {
            user_id: data.user_id || currentData.user_id,
            date: data.start_date || currentData.date,
            time: data.time || currentData.time,
            reason: data.reason || currentData.reason,
            status: data.status || currentData.status
          };
          
          if (data.substitute_id !== undefined) {
            earlyUpdateData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
          } else if (currentData.substitute_id) {
            earlyUpdateData.substitute_id = currentData.substitute_id;
          }
          
          const { error } = await supabase
            .from('early_departures')
            .update(earlyUpdateData)
            .eq('id', requestId);
          
          if (error) throw error;
        }
        
        return { success: true, data: { id: requestId, ...updateData } };
      }
    }
    
    // Se chegou aqui, existingRequest n√£o √© null
    // Se o tipo mudou (comparar o tipo original, n√£o o dbType)
    console.log('üîç Verificando mudan√ßa de tipo:', {
      tipoOriginal: type,
      tipoExistente: existingRequest.type,
      mudou: type !== existingRequest.type
    });
    
    if (type !== existingRequest.type) {
      // Caso especial: mudan√ßa para 'absence' (que n√£o existe na tabela requests)
      if (type === 'absence') {
        // Remover da tabela requests
        const { error: deleteError } = await supabase
          .from('requests')
          .delete()
          .eq('id', requestId);
        
        if (deleteError) throw deleteError;
        
        // Inserir na tabela time_off para ser uma absence (start_date = end_date)
        const timeOffInsertData: any = {
          id: requestId,
          user_id: data.user_id || existingRequest.user_id,
          start_date: data.start_date || existingRequest.start_date,
          end_date: data.start_date || existingRequest.start_date, // Para absence, start_date = end_date
          reason: data.reason || existingRequest.reason,
          status: data.status || existingRequest.status,
          created_at: currentTime,
          updated_at: currentTime
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          timeOffInsertData.substitute_id = data.substitute_id;
        }
        
        const { error: timeOffError } = await supabase
          .from('time_off')
          .insert(timeOffInsertData);
        
        if (timeOffError) {
          console.error('‚ùå Erro ao inserir na tabela time_off:', timeOffError);
          throw timeOffError;
        }
        console.log('‚úÖ Inser√ß√£o na tabela time_off bem-sucedida!');
        
        return { success: true, data: { id: requestId, ...updateData } };
      }
      // Remover da tabela espec√≠fica anterior
      if (existingRequest.type === 'time-off') {
        await supabase.from('time_off').delete().eq('id', requestId);
      } 
      else if (existingRequest.type === 'early-departure') {
        await supabase.from('early_departures').delete().eq('id', requestId);
      }
      else if (existingRequest.type === 'lateness') {
        await supabase.from('lateness').delete().eq('id', requestId);
      }
      
      // Atualizar a tabela requests
      const requestsUpdateData: any = {
        type: dbType as 'time-off' | 'early-departure' | 'lateness',
        user_id: data.user_id || existingRequest.user_id,
        start_date: data.start_date || existingRequest.start_date,
        end_date: dbType === 'time-off' ? (data.end_date || existingRequest.end_date) : null,
        time: dbType === 'early-departure' ? (data.time || existingRequest.time) : null,
        arrival_time: dbType === 'lateness' ? (data.arrival_time || existingRequest.arrival_time) : null,
        reason: data.reason || existingRequest.reason,
        status: data.status || existingRequest.status,
        updated_at: currentTime
      };
      
      // Adicionar substitute_id se fornecido
      if (data.substitute_id !== undefined) {
        requestsUpdateData.substitute_id = data.substitute_id;
      }
      
      const { error: updateError } = await supabase
        .from('requests')
        .update(requestsUpdateData)
        .eq('id', requestId);
      
      if (updateError) throw updateError;
      
      // Inserir na nova tabela espec√≠fica
      if (dbType === 'time-off') {
        const timeOffInsertData: any = {
          id: requestId,
          user_id: data.user_id || existingRequest.user_id,
          start_date: data.start_date || existingRequest.start_date,
          end_date: data.end_date || existingRequest.start_date,
          reason: data.reason || existingRequest.reason,
          status: data.status || existingRequest.status
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          timeOffInsertData.substitute_id = data.substitute_id;
        }
        
        const { error } = await supabase
          .from('time_off')
          .insert(timeOffInsertData);
        
        if (error) throw error;
      } 
      else if (dbType === 'early-departure') {
        const earlyInsertData: any = {
          id: requestId,
          user_id: data.user_id || existingRequest.user_id,
          date: data.start_date || existingRequest.start_date,
          time: data.time || '00:00',
          reason: data.reason || existingRequest.reason,
          status: data.status || existingRequest.status
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          earlyInsertData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
        } else if (existingRequest.substitute_id) {
          // Preservar substituto existente se n√£o foi fornecido um novo
          earlyInsertData.substitute_id = existingRequest.substitute_id;
        }
        
        const { error } = await supabase
          .from('early_departures')
          .insert(earlyInsertData);
        
        if (error) throw error;
      }
      else if (dbType === 'lateness') {
        const latenessInsertData: any = {
          id: requestId,
          user_id: data.user_id || existingRequest.user_id,
          date: data.start_date || existingRequest.start_date,
          arrival_time: data.arrival_time || '00:00',
          reason: data.reason || existingRequest.reason,
          status: data.status || existingRequest.status
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          latenessInsertData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
        } else if (existingRequest.substitute_id) {
          // Preservar substituto existente se n√£o foi fornecido um novo
          latenessInsertData.substitute_id = existingRequest.substitute_id;
        }
        
        const { error } = await supabase
          .from('lateness')
          .insert(latenessInsertData);
        
        if (error) throw error;
      }
      else if ((type as any) === 'absence') {
        // Se o novo tipo √© 'absence', remover da tabela 'requests' e inserir em 'time_off'
        const { error: deleteReqError } = await supabase
          .from('requests')
          .delete()
          .eq('id', requestId);
        if (deleteReqError) throw deleteReqError;

        const absenceInsertData: any = {
          id: requestId,
          user_id: data.user_id || existingRequest.user_id,
          start_date: data.start_date || existingRequest.start_date,
          end_date: data.start_date || existingRequest.start_date, // Mesmo dia para absence
          reason: data.reason || existingRequest.reason,
          status: data.status || existingRequest.status
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          absenceInsertData.substitute_id = data.substitute_id;
        }
        
        const { error: insertTimeOffError } = await supabase
          .from('time_off')
          .insert(absenceInsertData);
        if (insertTimeOffError) throw insertTimeOffError;
      }
    } else {
      // Se o tipo n√£o mudou (e n√£o √© 'absence')
      console.log('üìù Tipo n√£o mudou, apenas atualizando dados...');
      const currentType = dbType as 'time-off' | 'early-departure' | 'lateness';
      const requestsUpdateData: any = {
        user_id: data.user_id || existingRequest.user_id,
        start_date: data.start_date || existingRequest.start_date,
        end_date: currentType === 'time-off' ? (data.end_date || existingRequest.end_date) : null,
        time: currentType === 'early-departure' ? (data.time || existingRequest.time) : null,
        arrival_time: currentType === 'lateness' ? (data.arrival_time || existingRequest.arrival_time) : null,
        reason: data.reason || existingRequest.reason,
        status: data.status || existingRequest.status,
        updated_at: currentTime
      };
      
      // Adicionar substitute_id se fornecido
      if (data.substitute_id !== undefined) {
        requestsUpdateData.substitute_id = data.substitute_id;
      }
      
      const { error: updateError } = await supabase
        .from('requests')
        .update(requestsUpdateData)
        .eq('id', requestId);
      
      if (updateError) throw updateError;
      
      // Atualizar tabela espec√≠fica
      if (currentType === 'time-off') {
        const timeOffUpdateData: any = {
          user_id: data.user_id || existingRequest.user_id,
          start_date: data.start_date || existingRequest.start_date,
          end_date: data.end_date || existingRequest.end_date,
          reason: data.reason || existingRequest.reason,
          status: data.status || existingRequest.status
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          timeOffUpdateData.substitute_id = data.substitute_id;
        }
        
        const { error } = await supabase
          .from('time_off')
          .update(timeOffUpdateData)
          .eq('id', requestId);
        
        if (error) throw error;
      } 
      else if (currentType === 'early-departure') {
        const earlyUpdateData: any = {
          user_id: data.user_id || existingRequest.user_id,
          date: data.start_date || existingRequest.start_date,
          time: data.time || existingRequest.time,
          reason: data.reason || existingRequest.reason,
          status: data.status || existingRequest.status
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          earlyUpdateData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
        } else if (existingRequest.substitute_id) {
          // Preservar substituto existente se n√£o foi fornecido um novo
          earlyUpdateData.substitute_id = existingRequest.substitute_id;
        }
        
        const { error } = await supabase
          .from('early_departures')
          .update(earlyUpdateData)
          .eq('id', requestId);
        
        if (error) throw error;
      }
      else if (currentType === 'lateness') {
        const latenessUpdateData: any = {
          user_id: data.user_id || existingRequest.user_id,
          date: data.start_date || existingRequest.start_date,
          arrival_time: data.arrival_time || existingRequest.arrival_time,
          reason: data.reason || existingRequest.reason,
          status: data.status || existingRequest.status
        };
        
        // Adicionar substitute_id se fornecido
        if (data.substitute_id !== undefined) {
          latenessUpdateData.substitute_id = data.substitute_id === 'none' ? null : data.substitute_id;
        } else if (existingRequest.substitute_id) {
          // Preservar substituto existente se n√£o foi fornecido um novo
          latenessUpdateData.substitute_id = existingRequest.substitute_id;
        }
        
        const { error } = await supabase
          .from('lateness')
          .update(latenessUpdateData)
          .eq('id', requestId);
        
        if (error) throw error;
      }
    }
    
    return { success: true, data: { id: requestId, ...updateData } };
  } catch (error) {
    console.error('‚ùå DEBUG: Erro ao atualizar solicita√ß√£o:', error);
    return { success: false, error };
  }
};

export const getAllUsers = async () => {
  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('id, first_name')
      .order('first_name', { ascending: true });
    
    if (error) throw error;
    
    return { 
      success: true, 
      data: data.map(user => ({
        ...user,
        full_name: user.first_name
      }))
    };
  } catch (error) {
    console.error('Erro ao carregar usu√°rios:', error);
    return { success: false, error };
  }
};

// Fun√ß√£o para verificar e corrigir perfis de RLS
export async function checkAndFixRLS() {
  try {
    const { data: authUser } = await supabase.auth.getUser();
    if (!authUser?.user) return { success: true };
    
    const { data: existingProfile } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', authUser.user.id)
      .single();

    if (!existingProfile) {
      console.log('Perfil n√£o encontrado, criando perfil admin...');
      const { error } = await supabase.from('profiles').insert({
        id: authUser.user.id,
        first_name: 'Admin',
        last_name: 'User',
        role: 'admin',
        status: 'active',
        department: 'Administra√ß√£o',
        factory_id: '1',
        responsible: 'Sistema'
      });
      
      if (error) console.error('Erro ao criar perfil de admin:', error);
      else console.log('Perfil admin criado com sucesso!');
    }
    
    return { success: true };
  } catch (error) {
    console.error('Erro ao verificar/corrigir configura√ß√µes RLS:', error);
    return { success: false, error };
  }
}

// Fun√ß√£o para for√ßar redirecionamento
export const forceDashboardRedirect = () => {
  console.log("[Supabase] Executando redirecionamento manual para dashboard");
  
  // Obter a porta atual
  const port = window.location.port;
  const baseUrl = `${window.location.protocol}//${window.location.hostname}${port ? `:${port}` : ''}`;
  const dashboardUrl = `${baseUrl}/dashboard`;
  
  console.log("[Supabase] URL de redirecionamento:", dashboardUrl);
  
  // Redirecionar para o dashboard
  window.location.href = dashboardUrl;
};

// Removendo o timeout para n√£o causar redirecionamentos autom√°ticos conflitantes
// setTimeout(() => {
//   checkSessionAndRedirect();
// }, 1000);
// Arquivo corrigido automaticamente

// Fun√ß√£o para criar funcion√°rio sem afetar a sess√£o atual
export const createEmployeeWithoutAuth = async (employeeData: {
  first_name: string;
  name_japanese?: string;
  birth_date?: string;
  hire_date?: string;
  phone: string;
  password: string;
  department?: string;
  role?: string;
  responsible?: string;
  factory_id?: string | string[];
  city?: string;
  prestadora?: string;
}) => {
  try {
    console.log('Criando funcion√°rio com dados:', employeeData);
    
    // Salvar sess√£o atual do admin
    const { data: { session: currentSession } } = await supabase.auth.getSession();
    
    // 1. Criar usu√°rio no auth usando service_role (bypass RLS)
    const { data: authData, error: authError } = await supabaseAdmin.auth.admin.createUser({
      phone: employeeData.phone,
      password: employeeData.password,
      email_confirm: true,
      phone_confirm: true,
      user_metadata: {
        first_name: employeeData.first_name,
        name_japanese: employeeData.name_japanese || '',
        birth_date: employeeData.birth_date || '',
        hire_date: employeeData.hire_date || '',
        department: employeeData.department || '',
        role: employeeData.role || 'funcionario',
        responsible: employeeData.responsible || null,
        city: employeeData.city || '',
        prestadora: employeeData.prestadora || '',
        status: 'active'
      }
    });

    if (authError) {
      console.error('Erro ao criar usu√°rio no auth:', authError);
      throw authError;
    }

    if (!authData.user) {
      throw new Error('Usu√°rio n√£o foi criado no auth');
    }

    console.log('Usu√°rio criado no auth:', authData.user.id);

    // 2. CRIAR PERFIL MANUALMENTE (Trigger n√£o est√° funcionando devido a permiss√µes)
    const { error: profileError } = await supabaseAdmin
      .from('profiles')
      .insert({
        id: authData.user.id,
        phone: employeeData.phone,
        first_name: employeeData.first_name,
        name_japanese: employeeData.name_japanese || '',
        birth_date: employeeData.birth_date || null,
        hire_date: employeeData.hire_date || null,
        department: employeeData.department || '',
        role: (employeeData.role || 'funcionario') as 'funcionario' | 'superuser' | 'admin',
        responsible: employeeData.responsible || null,
        prestadora: employeeData.prestadora || null,
        status: 'active',
        factory_id: Array.isArray(employeeData.factory_id) 
          ? employeeData.factory_id[0] 
          : employeeData.factory_id || null,
        city: employeeData.city || null
      });

    if (profileError) {
      console.error('Erro ao criar perfil:', profileError);
      throw profileError;
    }

    console.log('Perfil criado manualmente com sucesso');

    // 3. Se tem f√°bricas selecionadas, associar
    if (employeeData.factory_id && authData.user.id) {
      const factoryIds = Array.isArray(employeeData.factory_id)
        ? employeeData.factory_id
        : [employeeData.factory_id];
        
      await updateEmployeeFactories(authData.user.id, factoryIds);
    }

    // 4. Restaurar sess√£o do admin
    if (currentSession) {
      await supabase.auth.setSession(currentSession);
      console.log('Sess√£o do admin restaurada');
    }

    return { success: true, user: authData.user };
  } catch (error) {
    console.error('Erro ao criar funcion√°rio:', error);
    return { success: false, error };
  }
};

// Fun√ß√£o para atualizar f√°bricas de um funcion√°rio
export const updateEmployeeFactories = async (userId: string, factoryIds: string[]) => {
  try {
    // Converter array para string se necess√°rio
    const factoryIdValue = factoryIds.length === 1 ? factoryIds[0] : factoryIds.join(',');
    
    const { error } = await supabase
      .from('profiles')
      .update({ factory_id: factoryIdValue })
      .eq('id', userId);

    if (error) {
      console.error('Erro ao atualizar f√°bricas do funcion√°rio:', error);
      throw error;
    }
    console.log('F√°bricas do funcion√°rio atualizadas com sucesso');
  } catch (error) {
    console.error('Erro ao atualizar f√°bricas do funcion√°rio:', error);
    throw error;
  }
};

// Cliente j√° exportado acima como named export

// Fun√ß√£o para obter cliente Supabase com configura√ß√µes personalizadas (usar apenas se necess√°rio)
export const getCustomSupabaseClient = (supabaseUrl: string, supabaseKey: string) => {
  try {
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('URL e chave do Supabase s√£o obrigat√≥rios');
    }

    // Salvar no localStorage para uso futuro
    if (typeof window !== 'undefined') {
      localStorage.setItem('supabaseUrl', supabaseUrl);
      localStorage.setItem('supabaseKey', supabaseKey);
    }

    console.log("[Supabase Client] Inicializando cliente personalizado com URL:", supabaseUrl);

    // Criar e retornar o cliente
    return createClient<Database>(supabaseUrl, supabaseKey, {
      auth: {
        persistSession: true,
        storageKey: 'supabase_auth_token',
        autoRefreshToken: true,
        detectSessionInUrl: true
      }
    });
  } catch (error) {
    console.error("[Supabase Client] Erro ao inicializar cliente personalizado:", error);
    
    // Em caso de erro, usar valores de fallback definidos explicitamente
    console.warn("[Supabase Client] Usando valores de fallback para inicializa√ß√£o de emerg√™ncia");
    return supabase; // Usar a inst√¢ncia principal
  }
};
